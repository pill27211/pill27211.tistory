
# [Diamond V] Star Trek - 17526

[문제 링크](https://www.acmicpc.net/problem/17526)

### 문제 요약

<p> 1에서 $n$으로 이동하려고 한다. 문제에 정의된 비용을 따를 때, 가장 최소의 비용으로 이동하는 경우를 구해보자. </p>

### 제한

TL : 1sec, ML : 512 MB

$3 ≤ n ≤ 100,000$

$0 ≤ p ≤ 1,000,000,000$

$1 ≤ s ≤ 100,000$

### 성능 요약

메모리: 13708 KB, 시간: 60 ms

### 분류

다이나믹 프로그래밍(dp), 볼록 껍질을 이용한 최적화(convex hull optimization)

### comment

이번에도 먼저 나이브한 방식을 생각해보자.

임의의 지점으로 가는 데엔 결국 그 이전 지점들 중에 어디에서 환승하냐가 관건이다.

두 지점 간 거리를 매번 계산할 순 없으니, 누적 합( $p[]$ )을 이용하자.

이후, 굉장히 쉽게 점화식을 만들어 볼 수 있다.

$dp[i]$ : $1$ ~ $i$까지 이동하는 데에 드는 최소 비용이라 할 때 $1 ≤ j < i$에 대해

$dp[i] = min(dp[i], dp[j] + a[j] + b[j] * (p[i] - p[j]))$

로 정의할 수 있다. 물론 모든 i에 대한 j를 돌아보면 $O(N^2)$.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

$p[i] = x$로 하는 직선의 방정식으로 정리해보자.

$f(x) = b[j] * x - b[j] * p[j] + a[j] + dp[j]$

상수가 딱히 없으므로 점화식 자체가 직선의 방정식을 이룬다.

내가 지금까지 풀어본 cht문제에선 단조성이 있었기에 스택의 개념을 이용한 간단한 형태로의 최적화가 가능했다.

하지만 위 식과 문제의 조건을 살펴보면 단조성을 볼 수가 없다.. (후에 기여탭에서 봤는데 식을 거리 기준으로 좀 더 잘 정리하면 Li Chao 트리 없이 가능 하다고 한다.)

<del> 그러나 풀 때의 나는 당연히 몰랐다. </del>

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

그렇게 결국 단조성이 없을 때도 적용이 가능한, 좀 더 일반적인 방식이 되는 Li Chao 트리를 공부하러 갔다.

공부는 [jhnah917님의 글](https://justicehui.github.io/hard-algorithm/2019/05/22/Li-Chao-Tree/)에서 하였다.

핵심만을 다루고 설명이 정말 깔끔 하시니 추천.

그렇게 Li Chao 트리를 공부 하고 나면, 정말 간단히 이 문제를 해결할 수 있다.

위에서 정리한 직선의 방정식의 형태 그대로 차례차례 추가 해보며 각 $p[i]$에 대한 최솟값 쿼리를 날려주면 된다.
