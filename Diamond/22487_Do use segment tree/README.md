
# [Diamond III] Do use segment tree - 22487

[문제 링크](https://www.acmicpc.net/problem/22487)

### 문제 요약

<p> 금광 세그를 선형 구조가 아닌 트리 위에서 한다면 ?  </p>

### 제한

TL : 2sec, ML : 512 MB

$1 ≤ n ≤ 200,000$

$1 ≤ q ≤ 100,000$

$w_i, c_i ≤ |10,000|$

### 성능 요약

메모리: 56308 KB, 시간: 764 ms

### 분류

구현(implementation), 자료 구조(data structures), 트리(trees), heavy-light 분할(heavy-light decomposition), 세그먼트 트리(segtree),
느리게 갱신되는 세그먼트 트리(lazy propagation)

### comment

이 문제를 시도하는 사람들이라면 이제는 웰노운이 돼버린 [이 문제](https://www.acmicpc.net/problem/16993)를 알고 있을 것이고, 풀어봤을 것이다.

그러나 여기선 두가지의 차이점이 존재한다.

* 선형 구조가 아닌, 트리 위에서 진행 한다는 것.
* 구간 단위 업데이트 쿼리가 추가 됐다는 것.

첫번째 차이점은 서브 트리에 국한되지 않고 임의의 두 정점을 잇는 경로를 넘나들테니, $hld$가 필수적인 듯 다. (세부적인 쿼리 처리는 잠시 재쳐두고)

두번째 차이점은 $lazy$ $propagation$을 적절히 끼얹으면 될 것 같다.

아무리 트리 위에서라 할 지라도 구조체 세그먼트 트리에서 관리해야 할 값들은 크게 다르지 않을테니, 풀이 방향이 대략 잡힌다.

앞서 소개한 선행 문제는 다들 풀어봤을 테니 구간 $merge$에 있어서는 설명을 생략 하겠다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

hld에선 체인 단위로 끌어 올려주며 쿼리를 날린다.

첫번째 쿼리인 업데이트 쿼리는 늘 하던데로 정점에 상관없이 깊이가 낮은 체인부터 올려주며 처리해도 문제가 없어 보인다.

오히려 이것 외에 한가지 주의할 점이 있다.

노드에 레이지를 뿌릴 때 어차피 그 구간에 모두 같은 값이 업데이트 될테니 $lz[n] * (e - s + 1)$ 의 값을 다 때려 박을 수도 있는데 

<del> 입구컷 당한다. </del>

그 구간에 총 합은 저 값이 맞지만, 음수로 내려갈 경우 개수를 최소화 하는 것이 더 이득이기 때문이다.

따라서 $ls$ : 최좌측을 포함한 최댓값, $rs$ : 최우측을 포함한 최댓값, $ms$ : 그 구간 내의 최대 연속합, $ps$ : 그 구간 내의 총 합

이라 할 때

$seg[n].ps = lz[n] * (e - s + 1)$

이고

$seg[n].ls = seg[n].rs = seg[n].ms = max(lz[n], seg[n].ps)$ 가 되겠다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

두번째 쿼리도 늘 하던데로 처리하고 싶지만, 그렇게 할 시 아쉽게도 $merge$ 해 온 구간이 연속적인지를 보장 받을 수 없다.

우리가 구하고자 하는 것은 경로 상 '최대 연속 합' 이니 연속성을 유지한 채 체인을 끌어 올려 주어야 한다.

그렇게 아래와 같은 코드가 탄생했다.

``` c++
ll f7(int p, int q)
{
	T x(seg[0]), y(seg[0]);
	while (top[p] ^ top[q])
	{
		if (D[top[p]] > D[top[q]])
			x = f(f5(1, 1, n, in[top[p]], in[p]), x), p = P[top[p]];
		else
			y = f(f5(1, 1, n, in[top[q]], in[q]), y), q = P[top[q]];
	}
	if (D[p] > D[q]) swap(p, q), swap(x, y);
	swap(x.ls, x.rs);
	return f(x, f(f5(1, 1, n, in[p], in[q]), y)).ms;
}
```
최초 시작 정점 $p, q$ 각각으로부터 체인을 따라 개별적으로 $merge$ 해 오다 보면, 결국 한 체인에 속하게 될 것이다.

이때 $p, q$ 중 어느 정점이 더 위에 있는지 알 수 없으니 일반성을 유지해 주었다.

최종적으로 일관된 방향에서의 마지막 $merge$를 하고 나면 드디어 구간 상 최대 연속합을 찾아낼 수 있다.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

![zzz](https://user-images.githubusercontent.com/120912574/228499725-5c39daf7-fc53-4f7c-ab3d-5f2ddd31df04.png)

그렇게 첫 다이아 3 문제 격파 성공.. 성불 완료...
