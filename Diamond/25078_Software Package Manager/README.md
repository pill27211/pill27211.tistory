
# [Diamond V] Software Package Manager - 25078

[문제 링크](https://www.acmicpc.net/problem/25078)

### 문제 요약

<p> $n$개의 정점으로 이루어진 트리와 $q$개의 쿼리가 주어진다. $install$, $uninstall$ 각각의 쿼리에 대해 알맞는 답을 출력해보자. </p>

### 제한

TL : 1sec, ML : 1024 MB

$7 ≤ n ≤ 100,000$

$5 ≤ q ≤ 100,000$

### 성능 요약

메모리: 16608 KB, 시간: 264 ms

### 분류

자료 구조(data_structures), 트리(trees), heavy-light 분할(heavy-light decomposition), 오일러 경로 테크닉(euler_tour technique), 
세그먼트 트리(segtree) 느리게 갱신되는 세그먼트 트리(lazy propagation)

### comment

[이 문제](https://www.acmicpc.net/problem/17429)의 하위 호환 격인 문제다.

경로에 대한 구간 쿼리를 처리해야 하므로 우선 hld로 트리를 분할하자.

쿼리를 해석하면 결국 $install$, $uninstall$ 각각의 처리 방법은 다음으로 귀결된다.

* $install$ $x$ : 루트 정점부터 $x$까지 이르는 경로 상의 $uninstall$( $0$ )된 정점의 수 ?
* $uninstall$ $x$ : $x$를 루트로 하는 서브 트리 내 $install$( $1$ )된 정점의 수 ?

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

상태가 $0$ 또는 $1$로 표현되는 세그먼트 트리를 생각해보자. 또, 구간 단위로 업데이트 해야 하니 레이지를 이용하자.

그럼 첫번째 쿼리는 전처리로 구한 $x$의 깊이에서 루트 정점부터 $x$까지 이르는 경로 상의 구간 합을 빼줌으로써 구할 수 있다.

체인 단위로 처리해야 하므로 업데이트 역시 체인 단위로 진행해 주어야 한다.

두번째 쿼리는 오일러 투어로 메겨진 $x$의 $in$과 $out$의 구간 합을 구해줌으로써 구할 수 있다.

서브 트리 단위 이므로 한 번의 호출을 통해 업데이트를 마칠 수 있다.

또한 기존과 달리 $0$역시 유효한 값이므로 레이지에서의 기저 상태를 $-1$로 정의하자.

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

끝.
